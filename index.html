<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Espectrofot√¥metro Profissional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #ffffff;
            padding: 15px;
            line-height: 1.5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #0a1931, #1a1a2e);
            border-radius: 15px;
            border: 1px solid #1e3a8a;
        }
        
        h1 {
            font-size: 22px;
            margin-bottom: 5px;
            color: #3b82f6;
            font-weight: 600;
        }
        
        .subtitle {
            font-size: 13px;
            opacity: 0.9;
            color: #93c5fd;
        }
        
        .video-section {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #1e40af;
        }
        
        .video-container {
            width: 100%;
            height: 180px;
            background: #000;
            border-radius: 10px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            border: 1px solid #334155;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: none;
        }
        
        #placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            background: #0f172a;
        }
        
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }
        
        button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        button:active { transform: scale(0.97); }
        
        #startBtn { 
            background: linear-gradient(135deg, #2563eb, #3b82f6);
            color: white;
        }
        
        #stopBtn { 
            background: linear-gradient(135deg, #dc2626, #ef4444);
            color: white;
            display: none;
        }
        
        #flipBtn { 
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: white;
            display: none;
        }
        
        .spectrum-section {
            background: rgba(15, 23, 42, 0.9);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #1e40af;
        }
        
        .chart-container {
            width: 100%;
            height: 320px;
            margin-bottom: 15px;
            position: relative;
        }
        
        #spectrumCanvas {
            width: 100%;
            height: 100%;
            background: #000;
            border-radius: 10px;
            border: 1px solid #334155;
        }
        
        .resolution-control {
            background: rgba(30, 41, 59, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
            color: #cbd5e1;
        }
        
        .slider-container {
            position: relative;
            height: 30px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #1e40af, #3b82f6);
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            border: 2px solid #3b82f6;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        .slider-ticks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 11px;
            color: #94a3b8;
        }
        
        .status-bar {
            background: rgba(30, 41, 59, 0.8);
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            color: #cbd5e1;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            font-size: 11px;
            color: #64748b;
        }
        
        @media (max-width: 480px) {
            .controls { flex-direction: column; }
            .chart-container { height: 280px; }
            .video-container { height: 160px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî¨ ESPECTROFOT√îMETRO PROFISSIONAL</h1>
            <p class="subtitle">Resolu√ß√£o de laborat√≥rio ‚Ä¢ An√°lise espectrofotom√©trica</p>
        </header>
        
        <section class="video-section">
            <div class="video-container">
                <div id="placeholder">
                    <div style="font-size: 36px; margin-bottom: 10px; color: #3b82f6;">üì°</div>
                    <p style="color: #cbd5e1;">Pronto para an√°lise espectrofotom√©trica</p>
                </div>
                <video id="video" autoplay playsinline muted></video>
            </div>
            
            <div class="controls">
                <button id="startBtn">
                    <span style="font-size: 16px;">‚ñ∂</span> INICIAR C√ÇMERA
                </button>
                <button id="stopBtn">
                    <span style="font-size: 16px;">‚èπ</span> PARAR
                </button>
                <button id="flipBtn">
                    <span style="font-size: 16px;">üîÑ</span> VIRAR
                </button>
            </div>
        </section>
        
        <section class="spectrum-section">
            <div class="chart-container">
                <canvas id="spectrumCanvas"></canvas>
            </div>
            
            <div class="resolution-control">
                <div class="control-group">
                    <div class="control-label">
                        <span>üìä RESOLU√á√ÉO ESPECTRAL</span>
                        <span id="resValue">0.5 nm</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="resSlider" min="1" max="5" value="1">
                    </div>
                    <div class="slider-ticks">
                        <span>0.2 nm</span>
                        <span>0.5 nm</span>
                        <span>1.0 nm</span>
                        <span>2.0 nm</span>
                        <span>5.0 nm</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">
                        <span>‚ö° FILTRO DE SUAVIZA√á√ÉO</span>
                        <span id="filterValue">Gaussiano</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="filterSlider" min="1" max="3" value="2">
                    </div>
                    <div class="slider-ticks">
                        <span>Baixo</span>
                        <span>M√©dio</span>
                        <span>Alto</span>
                    </div>
                </div>
            </div>
            
            <div class="status-bar">
                <span id="pointsCount">Pontos: 0</span>
                <span id="bandwidth">Largura: 0 nm</span>
                <span id="updateRate">Taxa: 0 Hz</span>
            </div>
        </section>
        
        <footer>
            <p>Espectrofot√¥metro Profissional v3.0 ‚Ä¢ Resolu√ß√£o de at√© 0.2 nm ‚Ä¢ Para an√°lise laboratorial</p>
            <p>‚ö†Ô∏è Este √© um simulador educacional baseado na resposta RGB da c√¢mera</p>
        </footer>
    </div>

    <script>
        // ========== CONFIGURA√á√ïES PROFISSIONAIS ==========
        const CONFIG = {
            resolutionLevels: {
                1: { step: 0.2, label: '0.2 nm' },  // 2500 pontos!
                2: { step: 0.5, label: '0.5 nm' },  // 1000 pontos
                3: { step: 1.0, label: '1.0 nm' },  // 500 pontos
                4: { step: 2.0, label: '2.0 nm' },  // 250 pontos
                5: { step: 5.0, label: '5.0 nm' }   // 100 pontos
            },
            filterTypes: {
                1: { type: 'moving', window: 3, label: 'M√©dia M√≥vel' },
                2: { type: 'gaussian', sigma: 1.5, label: 'Gaussiano' },
                3: { type: 'savitzky', window: 7, label: 'Savitzky-Golay' }
            }
        };
        
        // ========== ELEMENTOS DOM ==========
        const video = document.getElementById('video');
        const placeholder = document.getElementById('placeholder');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const flipBtn = document.getElementById('flipBtn');
        const canvas = document.getElementById('spectrumCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const resSlider = document.getElementById('resSlider');
        const resValue = document.getElementById('resValue');
        const filterSlider = document.getElementById('filterSlider');
        const filterValue = document.getElementById('filterValue');
        const pointsCount = document.getElementById('pointsCount');
        const bandwidth = document.getElementById('bandwidth');
        const updateRate = document.getElementById('updateRate');
        
        // ========== ESTADO ==========
        let stream = null;
        let isCameraActive = false;
        let useFrontCamera = false;
        let animationId = null;
        let lastUpdateTime = 0;
        let updateCounter = 0;
        let lastSpectrumData = null;
        
        // Buffer para suaviza√ß√£o
        const spectrumBuffer = [];
        const BUFFER_SIZE = 5;
        
        // ========== INICIALIZA√á√ÉO ==========
        function init() {
            canvas.width = canvas.clientWidth;
            canvas.height = 320;
            
            // Configurar controles
            resSlider.addEventListener('input', updateResolution);
            filterSlider.addEventListener('input', updateFilter);
            
            updateResolution();
            updateFilter();
            
            // Desenhar grade inicial
            drawEmptySpectrum();
        }
        
        // ========== CONTROLES ==========
        function updateResolution() {
            const level = CONFIG.resolutionLevels[resSlider.value];
            resValue.textContent = level.label;
        }
        
        function updateFilter() {
            const filter = CONFIG.filterTypes[filterSlider.value];
            filterValue.textContent = filter.label;
        }
        
        // ========== C√ÇMERA ==========
        startBtn.addEventListener('click', async () => {
            try {
                const constraints = {
                    video: {
                        facingMode: useFrontCamera ? 'user' : 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    },
                    audio: false
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play();
                    video.style.display = 'block';
                    placeholder.style.display = 'none';
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'flex';
                    flipBtn.style.display = 'flex';
                    isCameraActive = true;
                    
                    startSpectrumAnalysis();
                };
                
            } catch (error) {
                console.error('Erro c√¢mera:', error);
                alert('Permita o acesso √† c√¢mera!\n\nAtualize a p√°gina e toque em "PERMITIR".');
            }
        });
        
        flipBtn.addEventListener('click', () => {
            if (stream) stream.getTracks().forEach(t => t.stop());
            
            useFrontCamera = !useFrontCamera;
            video.style.display = 'none';
            placeholder.style.display = 'flex';
            startBtn.style.display = 'flex';
            stopBtn.style.display = 'none';
            flipBtn.style.display = 'none';
            isCameraActive = false;
            
            setTimeout(() => startBtn.click(), 300);
        });
        
        stopBtn.addEventListener('click', stopCamera);
        
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            video.style.display = 'none';
            placeholder.style.display = 'flex';
            startBtn.style.display = 'flex';
            stopBtn.style.display = 'none';
            flipBtn.style.display = 'none';
            isCameraActive = false;
            
            drawEmptySpectrum();
            clearStatus();
        }
        
        // ========== AN√ÅLISE ESPECTRAL PROFISSIONAL ==========
        function startSpectrumAnalysis() {
            if (animationId) cancelAnimationFrame(animationId);
            
            let lastFrameTime = 0;
            const targetFPS = 30;
            const frameInterval = 1000 / targetFPS;
            
            function analyzeLoop(timestamp) {
                if (!isCameraActive) return;
                
                if (timestamp - lastFrameTime >= frameInterval) {
                    analyzeHighResSpectrum();
                    lastFrameTime = timestamp;
                    
                    // Atualizar taxa de atualiza√ß√£o
                    updateCounter++;
                    const now = Date.now();
                    if (now - lastUpdateTime >= 1000) {
                        updateRate.textContent = `Taxa: ${updateCounter} Hz`;
                        updateCounter = 0;
                        lastUpdateTime = now;
                    }
                }
                
                animationId = requestAnimationFrame(analyzeLoop);
            }
            
            animationId = requestAnimationFrame(analyzeLoop);
        }
        
        function analyzeHighResSpectrum() {
            if (!isCameraActive || video.readyState !== video.HAVE_ENOUGH_DATA) return;
            
            try {
                // Criar canvas de an√°lise em alta resolu√ß√£o
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Usar tamanho m√°ximo para mais dados
                tempCanvas.width = video.videoWidth || 640;
                tempCanvas.height = video.videoHeight || 480;
                
                // Capturar frame
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Obter dados da imagem
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                // An√°lise espectrofotom√©trica avan√ßada
                const spectralResponse = analyzeSpectralResponse(data);
                const rawSpectrum = calculateRawSpectrum(spectralResponse);
                const filteredSpectrum = applySpectralFilter(rawSpectrum);
                
                // Adicionar ao buffer para suaviza√ß√£o temporal
                spectrumBuffer.push(filteredSpectrum);
                if (spectrumBuffer.length > BUFFER_SIZE) spectrumBuffer.shift();
                
                // Aplicar suaviza√ß√£o temporal
                const finalSpectrum = applyTemporalSmoothing(spectrumBuffer);
                lastSpectrumData = finalSpectrum;
                
                // Atualizar estat√≠sticas
                updateStatistics(finalSpectrum);
                
                // Renderizar espectro profissional
                renderProfessionalSpectrum(finalSpectrum);
                
            } catch (error) {
                console.log('Processando...');
            }
        }
        
        function analyzeSpectralResponse(data) {
            // An√°lise multivariada da resposta espectral
            const response = {
                uv: { sum: 0, count: 0 },
                blue: { sum: 0, count: 0 },
                cyan: { sum: 0, count: 0 },
                green: { sum: 0, count: 0 },
                yellow: { sum: 0, count: 0 },
                orange: { sum: 0, count: 0 },
                red: { sum: 0, count: 0 },
                farRed: { sum: 0, count: 0 },
                white: { sum: 0, count: 0 }
            };
            
            // An√°lise de cada pixel com classifica√ß√£o espectral precisa
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Converter RGB para coordenadas de cromaticidade
                const sum = r + g + b;
                if (sum === 0) continue;
                
                const x = r / sum;
                const y = g / sum;
                const z = b / sum;
                
                // Classifica√ß√£o espectral precisa
                if (b > r * 2 && b > g * 2) {
                    // UV/Violeta
                    response.uv.sum += b;
                    response.uv.count++;
                } else if (b > r && b > g) {
                    if (g > r * 1.2) {
                        // Ciano
                        response.cyan.sum += (b + g) / 2;
                        response.cyan.count++;
                    } else {
                        // Azul
                        response.blue.sum += b;
                        response.blue.count++;
                    }
                } else if (g > r && g > b) {
                    if (r > b * 1.2) {
                        // Amarelo
                        response.yellow.sum += (g + r) / 2;
                        response.yellow.count++;
                    } else {
                        // Verde
                        response.green.sum += g;
                        response.green.count++;
                    }
                } else if (r > g && r > b) {
                    if (g > b * 1.5) {
                        // Laranja
                        response.orange.sum += (r + g) / 2;
                        response.orange.count++;
                    } else if (r > 200 && g < 100 && b < 100) {
                        // Vermelho distante
                        response.farRed.sum += r;
                        response.farRed.count++;
                    } else {
                        // Vermelho
                        response.red.sum += r;
                        response.red.count++;
                    }
                } else {
                    // Branco/cinza
                    response.white.sum += (r + g + b) / 3;
                    response.white.count++;
                }
            }
            
            // Normalizar respostas
            Object.keys(response).forEach(key => {
                if (response[key].count > 0) {
                    response[key].avg = response[key].sum / response[key].count;
                } else {
                    response[key].avg = 0;
                }
            });
            
            return response;
        }
        
        function calculateRawSpectrum(response) {
            const resolution = CONFIG.resolutionLevels[resSlider.value];
            const spectrum = [];
            
            // Gerar espectro com resolu√ß√£o de laborat√≥rio
            for (let wavelength = 300; wavelength <= 800; wavelength += resolution.step) {
                let intensity = 0;
                
                // Fun√ß√µes de resposta espectral sobrepostas (como em espectrofot√¥metros reais)
                const responses = [
                    // UV/Violeta (300-420nm) - Gaussiana larga
                    { range: [300, 420], source: 'uv', center: 380, width: 60, weight: 0.8 },
                    
                    // Azul (420-490nm) - Duas gaussianas sobrepostas
                    { range: [420, 490], source: 'blue', center: 450, width: 35, weight: 1.0 },
                    { range: [420, 490], source: 'cyan', center: 470, width: 40, weight: 0.3 },
                    
                    // Ciano/Verde (490-560nm) - Transi√ß√£o suave
                    { range: [490, 560], source: 'cyan', center: 510, width: 35, weight: 0.6 },
                    { range: [490, 560], source: 'green', center: 540, width: 40, weight: 0.8 },
                    
                    // Verde/Amarelo (560-600nm)
                    { range: [560, 600], source: 'green', center: 570, width: 30, weight: 0.5 },
                    { range: [560, 600], source: 'yellow', center: 580, width: 35, weight: 0.9 },
                    
                    // Amarelo/Laranja (600-640nm)
                    { range: [600, 640], source: 'yellow', center: 610, width: 30, weight: 0.4 },
                    { range: [600, 640], source: 'orange', center: 620, width: 35, weight: 0.8 },
                    
                    // Laranja/Vermelho (640-690nm)
                    { range: [640, 690], source: 'orange', center: 660, width: 40, weight: 0.5 },
                    { range: [640, 690], source: 'red', center: 670, width: 45, weight: 1.0 },
                    
                    // Vermelho/Vermelho distante (690-800nm)
                    { range: [690, 800], source: 'red', center: 710, width: 60, weight: 0.6 },
                    { range: [690, 800], source: 'farRed', center: 730, width: 80, weight: 0.8 }
                ];
                
                // Somar todas as contribui√ß√µes
                responses.forEach(resp => {
                    if (wavelength >= resp.range[0] && wavelength <= resp.range[1]) {
                        const sourceValue = response[resp.source]?.avg || 0;
                        intensity += sourceValue * resp.weight * 
                                    gaussian(wavelength, resp.center, resp.width);
                    }
                });
                
                // Adicionar fundo cont√≠nuo (resposta do branco)
                intensity += response.white.avg * 0.4 * gaussian(wavelength, 550, 250);
                
                // Adicionar ru√≠do espectral m√≠nimo (realismo)
                intensity += (Math.random() - 0.5) * 0.5;
                
                spectrum.push({
                    wavelength: wavelength,
                    intensity: Math.max(0, Math.min(255, intensity))
                });
            }
            
            return spectrum;
        }
        
        function applySpectralFilter(spectrum) {
            const filterType = CONFIG.filterTypes[filterSlider.value];
            
            switch(filterType.type) {
                case 'moving':
                    return applyMovingAverage(spectrum, filterType.window);
                    
                case 'gaussian':
                    return applyGaussianFilter(spectrum, filterType.sigma);
                    
                case 'savitzky':
                    return applySavitzkyGolay(spectrum, filterType.window);
                    
                default:
                    return spectrum;
            }
        }
        
        function applyMovingAverage(spectrum, windowSize) {
            const filtered = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < spectrum.length; i++) {
                let sum = 0;
                let count = 0;
                
                for (let j = Math.max(0, i - halfWindow); j <= Math.min(spectrum.length - 1, i + halfWindow); j++) {
                    sum += spectrum[j].intensity;
                    count++;
                }
                
                filtered.push({
                    wavelength: spectrum[i].wavelength,
                    intensity: sum / count
                });
            }
            
            return filtered;
        }
        
        function applyGaussianFilter(spectrum, sigma) {
            const filtered = [];
            const kernelSize = Math.floor(sigma * 3);
            
            for (let i = 0; i < spectrum.length; i++) {
                let weightedSum = 0;
                let weightSum = 0;
                
                for (let j = -kernelSize; j <= kernelSize; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < spectrum.length) {
                        const weight = gaussian(j, 0, sigma);
                        weightedSum += spectrum[idx].intensity * weight;
                        weightSum += weight;
                    }
                }
                
                filtered.push({
                    wavelength: spectrum[i].wavelength,
                    intensity: weightedSum / weightSum
                });
            }
            
            return filtered;
        }
        
        function applySavitzkyGolay(spectrum, window) {
            // Coeficientes para filtro Savitzky-Golay (janela 7, ordem 3)
            const coefficients = [-2, 3, 6, 7, 6, 3, -2];
            const norm = 21;
            
            const filtered = [];
            const halfWindow = Math.floor(window / 2);
            
            for (let i = 0; i < spectrum.length; i++) {
                let sum = 0;
                let coeffSum = 0;
                
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = i + j;
                    if (idx >= 0 && idx < spectrum.length) {
                        const coeff = coefficients[j + halfWindow];
                        sum += spectrum[idx].intensity * coeff;
                        coeffSum += coeff;
                    }
                }
                
                filtered.push({
                    wavelength: spectrum[i].wavelength,
                    intensity: sum / norm
                });
            }
            
            return filtered;
        }
        
        function applyTemporalSmoothing(buffer) {
            if (buffer.length === 0) return [];
            if (buffer.length === 1) return buffer[0];
            
            const smoothed = [];
            const weights = [0.1, 0.15, 0.25, 0.25, 0.25]; // Peso exponencial
            
            for (let i = 0; i < buffer[0].length; i++) {
                let total = 0;
                let weightSum = 0;
                
                for (let j = 0; j < buffer.length; j++) {
                    const weight = weights[Math.min(j, weights.length - 1)];
                    total += buffer[j][i].intensity * weight;
                    weightSum += weight;
                }
                
                smoothed.push({
                    wavelength: buffer[0][i].wavelength,
                    intensity: total / weightSum
                });
            }
            
            return smoothed;
        }
        
        // ========== RENDERIZA√á√ÉO PROFISSIONAL ==========
        function renderProfessionalSpectrum(spectrum) {
            const width = canvas.width;
            const height = canvas.height;
            const dpr = window.devicePixelRatio || 1;
            
            // Configurar canvas de alta resolu√ß√£o
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            
            // Limpar com fundo preto
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            
            // Desenhar grade profissional
            drawProfessionalGrid(width, height);
            
            // Desenhar espectro suave
            if (spectrum.length > 0) {
                drawSmoothSpectrumLine(spectrum, width, height);
                drawSpectralFeatures(spectrum, width, height);
            }
            
            // Desenhar informa√ß√µes
            drawSpectrumInfo(width, height, spectrum);
            
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        
        function drawProfessionalGrid(width, height) {
            // Grade principal
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.15)';
            ctx.lineWidth = 1;
            
            // Linhas horizontais
            for (let i = 1; i <= 5; i++) {
                const y = 40 + (i * (height - 80) / 6);
                ctx.beginPath();
                ctx.moveTo(40, y);
                ctx.lineTo(width - 20, y);
                ctx.stroke();
            }
            
            // Linhas verticais (comprimentos de onda importantes)
            const wavelengths = [300, 380, 450, 530, 630, 700, 800];
            wavelengths.forEach(wl => {
                const x = 40 + ((wl - 300) / 500) * (width - 60);
                ctx.beginPath();
                ctx.moveTo(x, 40);
                ctx.lineTo(x, height - 40);
                ctx.stroke();
            });
            
            // Eixos
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1.5;
            
            // Eixo X
            ctx.beginPath();
            ctx.moveTo(40, height - 40);
            ctx.lineTo(width - 20, height - 40);
            ctx.stroke();
            
            // Eixo Y
            ctx.beginPath();
            ctx.moveTo(40, 40);
            ctx.lineTo(40, height - 40);
            ctx.stroke();
            
            // Marcadores do eixo X
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px "Courier New", monospace';
            ctx.textAlign = 'center';
            
            wavelengths.forEach(wl => {
                const x = 40 + ((wl - 300) / 500) * (width - 60);
                ctx.beginPath();
                ctx.moveTo(x, height - 40);
                ctx.lineTo(x, height - 35);
                ctx.stroke();
                
                ctx.fillText(wl + ' nm', x, height - 20);
            });
            
            // Marcadores do eixo Y
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const y = height - 40 - (i * (height - 80) / 5);
                const value = i * 20;
                ctx.fillText(value + '%', 35, y + 4);
            }
        }
        
        function drawSmoothSpectrumLine(spectrum, width, height) {
            // Encontrar m√°ximo para normaliza√ß√£o
            const maxIntensity = Math.max(...spectrum.map(s => s.intensity), 1);
            
            // Criar gradiente espectral para a linha
            const lineGradient = ctx.createLinearGradient(40, 0, width - 20, 0);
            lineGradient.addColorStop(0.0, '#8b5cf6');   // Violeta
            lineGradient.addColorStop(0.2, '#3b82f6');   // Azul
            lineGradient.addColorStop(0.4, '#06b6d4');   // Ciano
            lineGradient.addColorStop(0.6, '#10b981');   // Verde
            lineGradient.addColorStop(0.8, '#f59e0b');   // Amarelo/Laranja
            lineGradient.addColorStop(1.0, '#ef4444');   // Vermelho
            
            // Desenhar linha com interpola√ß√£o c√∫bica
            ctx.beginPath();
            ctx.lineWidth = 2.2;
            ctx.strokeStyle = lineGradient;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            // Usar amostragem adaptativa para suavidade
            const step = Math.max(1, Math.floor(spectrum.length / 400));
            const points = [];
            
            for (let i = 0; i < spectrum.length; i += step) {
                const point = spectrum[i];
                const x = 40 + ((point.wavelength - 300) / 500) * (width - 60);
                const y = height - 40 - (point.intensity / maxIntensity * (height - 80));
                
                points.push({ x, y });
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    // Interpola√ß√£o c√∫bica de Catmull-Rom para m√°xima suavidade
                    const p0 = points[Math.max(0, points.length - 3)];
                    const p1 = points[points.length - 2];
                    const p2 = { x, y };
                    
                    const tension = 0.5;
                    const t = 0.5;
                    
                    const m1x = (p2.x - p0.x) * tension;
                    const m1y = (p2.y - p0.y) * tension;
                    const m2x = (p2.x - p1.x) * tension;
                    const m2y = (p2.y - p1.y) * tension;
                    
                    const t2 = t * t;
                    const t3 = t2 * t;
                    
                    const h1 = 2 * t3 - 3 * t2 + 1;
                    const h2 = -2 * t3 + 3 * t2;
                    const h3 = t3 - 2 * t2 + t;
                    const h4 = t3 - t2;
                    
                    const xc = h1 * p1.x + h2 * p2.x + h3 * m1x + h4 * m2x;
                    const yc = h1 * p1.y + h2 * p2.y + h3 * m1y + h4 * m2y;
                    
                    ctx.quadraticCurveTo(xc, yc, x, y);
                }
            }
            
            ctx.stroke();
            
            // Preenchimento suave com gradiente
            ctx.lineTo(width - 20, height - 40);
            ctx.lineTo(40, height - 40);
            ctx.closePath();
            
            const fillGradient = ctx.createLinearGradient(0, 0, 0, height);
            fillGradient.addColorStop(0, 'rgba(59, 130, 246, 0.1)');
            fillGradient.addColorStop(0.5, 'rgba(59, 130, 246, 0.05)');
            fillGradient.addColorStop(1, 'rgba(59, 130, 246, 0.01)');
            ctx.fillStyle = fillGradient;
            ctx.fill();
        }
        
        function drawSpectralFeatures(spectrum, width, height) {
            if (spectrum.length < 10) return;
            
            // Encontrar picos significativos
            const peaks = findSignificantPeaks(spectrum);
            
            // Marcar picos importantes
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 11px Arial';
            ctx.textAlign = 'center';
            
            peaks.forEach(peak => {
                if (peak.prominence > 5) { // Apenas picos significativos
                    const x = 40 + ((peak.wavelength - 300) / 500) * (width - 60);
                    const y = height - 40 - (peak.intensity / 255 * (height - 80));
                    
                    // Marcador do pico
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = '#ef4444';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // R√≥tulo
                    ctx.fillStyle = 'white';
                    ctx.fillText(`Œª=${peak.wavelength}nm`, x, y - 10);
                }
            });
        }
        
        function findSignificantPeaks(spectrum) {
            const peaks = [];
            const window = 5;
            
            for (let i = window; i < spectrum.length - window; i++) {
                let isPeak = true;
                
                // Verificar se √© um m√°ximo local
                for (let j = i - window; j <= i + window; j++) {
                    if (j !== i && spectrum[j].intensity >= spectrum[i].intensity) {
                        isPeak = false;
                        break;
                    }
                }
                
                if (isPeak) {
                    // Calcular proemin√™ncia do pico
                    let leftMin = Infinity;
                    let rightMin = Infinity;
                    
                    for (let j = i - window; j < i; j++) {
                        if (spectrum[j].intensity < leftMin) leftMin = spectrum[j].intensity;
                    }
                    for (let j = i + 1; j <= i + window; j++) {
                        if (spectrum[j].intensity < rightMin) rightMin = spectrum[j].intensity;
                    }
                    
                    const prominence = spectrum[i].intensity - Math.max(leftMin, rightMin);
                    
                    peaks.push({
                        wavelength: spectrum[i].wavelength,
                        intensity: spectrum[i].intensity,
                        prominence: prominence
                    });
                }
            }
            
            return peaks.sort((a, b) => b.prominence - a.prominence).slice(0, 5);
        }
        
        function drawSpectrumInfo(width, height, spectrum) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 14px "Segoe UI", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('AN√ÅLISE ESPECTROFOTOM√âTRICA', 50, 30);
            
            ctx.font = '11px "Courier New", monospace';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            
            const resolution = CONFIG.resolutionLevels[resSlider.value];
            const filter = CONFIG.filterTypes[filterSlider.value];
            
            ctx.fillText(`Resolu√ß√£o: ${resolution.label}`, 50, height - 70);
            ctx.fillText(`Filtro: ${filter.label}`, 50, height - 55);
            ctx.fillText(`Pontos: ${spectrum.length}`, 50, height - 40);
            
            if (spectrum.length > 0) {
                const avgIntensity = spectrum.reduce((sum, s) => sum + s.intensity, 0) / spectrum.length;
                ctx.fillText(`Intensidade m√©dia: ${avgIntensity.toFixed(1)}`, width - 200, height - 70);
            }
        }
        
        function drawEmptySpectrum() {
            const width = canvas.width = canvas.clientWidth;
            const height = canvas.height = 320;
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            
            drawProfessionalGrid(width, height);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '16px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('AGUARDANDO AN√ÅLISE ESPECTRAL', width / 2, height / 2);
        }
        
        function updateStatistics(spectrum) {
            pointsCount.textContent = `Pontos: ${spectrum.length}`;
            
            if (spectrum.length > 0) {
                const bandwidthValue = spectrum[spectrum.length - 1].wavelength - spectrum[0].wavelength;
                bandwidth.textContent = `Largura: ${bandwidthValue.toFixed(1)} nm`;
            }
        }
        
        function clearStatus() {
            pointsCount.textContent = 'Pontos: 0';
            bandwidth.textContent = 'Largura: 0 nm';
            updateRate.textContent = 'Taxa: 0 Hz';
        }
        
        // ========== FUN√á√ïES AUXILIARES ==========
        function gaussian(x, mean, sigma) {
            return Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(sigma, 2)));
        }
        
        // ========== INICIAR APLICA√á√ÉO ==========
        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('resize', () => {
            canvas.width = canvas.clientWidth;
            if (!isCameraActive) {
                drawEmptySpectrum();
            }
        });
    </script>
</body>
</html>
