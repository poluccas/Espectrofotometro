<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Espectr√¥metro HD</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #ffffff;
            padding: 15px;
            line-height: 1.5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #1a237e, #311b92);
            border-radius: 15px;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #64b5f6;
        }
        
        .video-section {
            background: rgba(30, 30, 40, 0.8);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .video-container {
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 10px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            display: none;
        }
        
        #placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        button:active { transform: scale(0.95); }
        
        #startBtn { background: #2196F3; color: white; }
        #stopBtn { background: #f44336; color: white; display: none; }
        
        .spectrum-section {
            background: rgba(30, 30, 40, 0.8);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            width: 100%;
            height: 350px;
            margin-bottom: 20px;
        }
        
        #spectrumCanvas {
            width: 100%;
            height: 100%;
            background: #000;
            border-radius: 10px;
            border: 1px solid #333;
        }
        
        .quality-control {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2196F3;
            cursor: pointer;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            font-size: 12px;
            color: #888;
        }
        
        @media (max-width: 480px) {
            .controls { flex-direction: column; }
            .chart-container { height: 300px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî¨ Espectr√¥metro HD</h1>
            <p>Alta resolu√ß√£o - An√°lise suave do espectro</p>
        </header>
        
        <section class="video-section">
            <div class="video-container">
                <div id="placeholder">
                    <div style="font-size: 48px; margin-bottom: 10px;">üì±</div>
                    <p>Toque em INICIAR C√ÇMERA</p>
                </div>
                <video id="video" autoplay playsinline muted></video>
            </div>
            
            <div class="controls">
                <button id="startBtn">‚ñ∂ INICIAR C√ÇMERA</button>
                <button id="stopBtn">‚èπ PARAR C√ÇMERA</button>
            </div>
        </section>
        
        <section class="spectrum-section">
            <div class="chart-container">
                <canvas id="spectrumCanvas"></canvas>
            </div>
            
            <div class="quality-control">
                <div class="slider-container">
                    <div class="slider-label">
                        <span>üìä Suaviza√ß√£o do Espectro</span>
                        <span id="smoothValue">Alta</span>
                    </div>
                    <input type="range" id="smoothSlider" min="1" max="3" value="3">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>‚ö° Velocidade de Atualiza√ß√£o</span>
                        <span id="speedValue">Normal</span>
                    </div>
                    <input type="range" id="speedSlider" min="1" max="3" value="2">
                </div>
            </div>
        </section>
        
        <footer>
            <p>Espectr√¥metro HD v2.0 - Resolu√ß√£o otimizada para an√°lise cont√≠nua</p>
            <p>üå± Para l√¢mpadas de cultivo - Espectro suave e preciso</p>
        </footer>
    </div>

    <script>
        // Elementos
        const video = document.getElementById('video');
        const placeholder = document.getElementById('placeholder');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const canvas = document.getElementById('spectrumCanvas');
        const ctx = canvas.getContext('2d');
        const smoothSlider = document.getElementById('smoothSlider');
        const smoothValue = document.getElementById('smoothValue');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        
        // Estado
        let stream = null;
        let isCameraActive = false;
        let animationId = null;
        
        // Hist√≥rico para suaviza√ß√£o
        let colorHistory = [];
        const HISTORY_SIZE = 10;
        
        // Configura√ß√µes
        const smoothLevels = {
            1: { label: 'Baixa', factor: 0.3 },
            2: { label: 'M√©dia', factor: 0.6 },
            3: { label: 'Alta', factor: 0.9 }
        };
        
        const speedLevels = {
            1: { label: 'Lenta', interval: 1000 },
            2: { label: 'Normal', interval: 300 },
            3: { label: 'R√°pida', interval: 100 }
        };
        
        // Configurar controles
        smoothSlider.addEventListener('input', function() {
            smoothValue.textContent = smoothLevels[this.value].label;
        });
        
        speedSlider.addEventListener('input', function() {
            speedValue.textContent = speedLevels[this.value].label;
        });
        
        // 1. INICIAR C√ÇMERA
        startBtn.addEventListener('click', async () => {
            try {
                // M√©todo simples para Android
                const constraints = {
                    video: { facingMode: 'environment' },
                    audio: false
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play();
                    video.style.display = 'block';
                    placeholder.style.display = 'none';
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'block';
                    isCameraActive = true;
                    
                    // Iniciar an√°lise
                    startAnalysis();
                };
                
            } catch (error) {
                alert('Permita o acesso √† c√¢mera!\n\nAtualize a p√°gina e tente novamente.');
            }
        });
        
        // 2. AN√ÅLISE PRINCIPAL
        function startAnalysis() {
            if (animationId) cancelAnimationFrame(animationId);
            
            function analyze() {
                if (!isCameraActive) return;
                
                const speed = speedLevels[speedSlider.value].interval;
                
                // Controlar taxa de atualiza√ß√£o
                setTimeout(() => {
                    analyzeFrame();
                    animationId = requestAnimationFrame(analyze);
                }, speed);
            }
            
            analyze();
        }
        
        // 3. ANALISAR FRAME COM ALTA RESOLU√á√ÉO
        function analyzeFrame() {
            if (!isCameraActive || video.readyState !== video.HAVE_ENOUGH_DATA) return;
            
            try {
                // Criar canvas de an√°lise
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // Usar tamanho maior para mais dados
                tempCanvas.width = 640;
                tempCanvas.height = 480;
                
                // Capturar frame
                tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                
                // Obter dados da imagem
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                // ANALISAR COM MAIS DETALHE
                // Dividir a imagem em regi√µes para an√°lise espacial
                const regions = analyzeRegions(data, tempCanvas.width, tempCanvas.height);
                
                // Calcular espectro de alta resolu√ß√£o
                const spectrum = calculateHighResSpectrum(regions);
                
                // Aplicar suaviza√ß√£o temporal
                colorHistory.push(spectrum);
                if (colorHistory.length > HISTORY_SIZE) {
                    colorHistory.shift();
                }
                
                const smoothedSpectrum = smoothSpectrum(colorHistory);
                
                // Desenhar espectro suave
                drawHighResSpectrum(smoothedSpectrum);
                
            } catch (error) {
                console.log('Processando...');
            }
        }
        
        // 4. ANALISAR REGI√ïES DA IMAGEM
        function analyzeRegions(data, width, height) {
            const regions = {
                red: { total: 0, count: 0 },
                green: { total: 0, count: 0 },
                blue: { total: 0, count: 0 },
                yellow: { total: 0, count: 0 },
                cyan: { total: 0, count: 0 },
                magenta: { total: 0, count: 0 },
                white: { total: 0, count: 0 }
            };
            
            // Analisar cada pixel
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Classificar por cor dominante com mais nuances
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;
                
                if (diff < 30) {
                    // Tons de cinza/branco
                    regions.white.total += (r + g + b) / 3;
                    regions.white.count++;
                } else if (r > g && r > b) {
                    // Vermelho dominante
                    if (g > b * 1.5) {
                        // Amarelo (vermelho + verde)
                        regions.yellow.total += (r + g) / 2;
                        regions.yellow.count++;
                    } else {
                        regions.red.total += r;
                        regions.red.count++;
                    }
                } else if (g > r && g > b) {
                    // Verde dominante
                    if (b > r * 1.5) {
                        // Ciano (verde + azul)
                        regions.cyan.total += (g + b) / 2;
                        regions.cyan.count++;
                    } else {
                        regions.green.total += g;
                        regions.green.count++;
                    }
                } else {
                    // Azul dominante
                    if (r > g * 1.5) {
                        // Magenta (azul + vermelho)
                        regions.magenta.total += (b + r) / 2;
                        regions.magenta.count++;
                    } else {
                        regions.blue.total += b;
                        regions.blue.count++;
                    }
                }
            }
            
            return regions;
        }
        
        // 5. CALCULAR ESPECTRO DE ALTA RESOLU√á√ÉO
        function calculateHighResSpectrum(regions) {
            const spectrum = [];
            const smoothFactor = smoothLevels[smoothSlider.value].factor;
            
            // Comprimentos de onda de 300nm a 800nm com alta resolu√ß√£o
            for (let wavelength = 300; wavelength <= 800; wavelength += 1) { // 1nm de resolu√ß√£o!
                let intensity = 0;
                
                // Fun√ß√µes de resposta espectral mais suaves e sobrepostas
                if (wavelength < 400) {
                    // UV/Violeta - baseado em azul e magenta
                    intensity = (regions.blue.total / Math.max(1, regions.blue.count)) * 0.7 +
                               (regions.magenta.total / Math.max(1, regions.magenta.count)) * 0.3;
                    intensity *= gaussian(wavelength, 380, 50);
                } 
                else if (wavelength < 450) {
                    // Azul/violeta - transi√ß√£o suave
                    intensity = (regions.blue.total / Math.max(1, regions.blue.count)) * 0.8 +
                               (regions.cyan.total / Math.max(1, regions.cyan.count)) * 0.2;
                    intensity *= gaussian(wavelength, 425, 40);
                }
                else if (wavelength < 500) {
                    // Azul/ciano
                    intensity = (regions.blue.total / Math.max(1, regions.blue.count)) * 0.6 +
                               (regions.cyan.total / Math.max(1, regions.cyan.count)) * 0.4;
                    intensity *= gaussian(wavelength, 475, 35);
                }
                else if (wavelength < 550) {
                    // Verde/ciano - transi√ß√£o
                    intensity = (regions.green.total / Math.max(1, regions.green.count)) * 0.7 +
                               (regions.cyan.total / Math.max(1, regions.cyan.count)) * 0.3;
                    intensity *= gaussian(wavelength, 525, 35);
                }
                else if (wavelength < 600) {
                    // Verde/amarelo
                    intensity = (regions.green.total / Math.max(1, regions.green.count)) * 0.6 +
                               (regions.yellow.total / Math.max(1, regions.yellow.count)) * 0.4;
                    intensity *= gaussian(wavelength, 575, 40);
                }
                else if (wavelength < 650) {
                    // Amarelo/laranja
                    intensity = (regions.yellow.total / Math.max(1, regions.yellow.count)) * 0.7 +
                               (regions.red.total / Math.max(1, regions.red.count)) * 0.3;
                    intensity *= gaussian(wavelength, 625, 40);
                }
                else if (wavelength < 700) {
                    // Vermelho/laranja
                    intensity = (regions.red.total / Math.max(1, regions.red.count)) * 0.8 +
                               (regions.magenta.total / Math.max(1, regions.magenta.count)) * 0.2;
                    intensity *= gaussian(wavelength, 675, 45);
                }
                else {
                    // Vermelho profundo
                    intensity = (regions.red.total / Math.max(1, regions.red.count)) * 0.9 +
                               (regions.magenta.total / Math.max(1, regions.magenta.count)) * 0.1;
                    intensity *= gaussian(wavelength, 750, 60);
                }
                
                // Adicionar fundo cont√≠nuo (branco/cinza)
                const whiteLevel = regions.white.total / Math.max(1, regions.white.count);
                intensity += whiteLevel * 0.3 * gaussian(wavelength, 550, 200);
                
                // Aplicar suaviza√ß√£o
                intensity = intensity * smoothFactor + (Math.random() * 5) * (1 - smoothFactor);
                
                spectrum.push({
                    wavelength: wavelength,
                    intensity: Math.max(0, Math.min(255, intensity))
                });
            }
            
            return spectrum;
        }
        
        // 6. SUAVIZA√á√ÉO TEMPORAL
        function smoothSpectrum(history) {
            if (history.length === 0) return [];
            
            const smoothed = [];
            const weights = [0.1, 0.15, 0.2, 0.25, 0.3]; // Peso maior para medi√ß√µes mais recentes
            
            for (let i = 0; i < history[0].length; i++) {
                let total = 0;
                let weightSum = 0;
                
                for (let j = 0; j < history.length; j++) {
                    const weight = weights[Math.min(j, weights.length - 1)];
                    total += history[j][i].intensity * weight;
                    weightSum += weight;
                }
                
                smoothed.push({
                    wavelength: history[0][i].wavelength,
                    intensity: total / weightSum
                });
            }
            
            return smoothed;
        }
        
        // 7. DESENHAR ESPECTRO DE ALTA RESOLU√á√ÉO
        function drawHighResSpectrum(spectrum) {
            const width = canvas.width = canvas.clientWidth;
            const height = canvas.height = 350;
            
            // Limpar canvas
            ctx.clearRect(0, 0, width, height);
            
            // Fundo com gradiente do espectro REAL
            drawSpectrumBackground(width, height);
            
            // Encontrar intensidade m√°xima para normalizar
            const maxIntensity = Math.max(...spectrum.map(s => s.intensity), 1);
            
            // Desenhar linha SMOOTH com interpola√ß√£o c√∫bica
            drawSmoothLine(spectrum, width, height, maxIntensity);
            
            // Eixos e informa√ß√µes
            drawAxesAndInfo(width, height, maxIntensity);
        }
        
        function drawSpectrumBackground(width, height) {
            // Gradiente REAL do espectro vis√≠vel
            const gradient = ctx.createLinearGradient(0, 0, width, 0);
            
            // Cores mais precisas do espectro
            gradient.addColorStop(0.00, 'rgba(75, 0, 130, 0.15)');  // Violeta profundo
            gradient.addColorStop(0.10, 'rgba(138, 43, 226, 0.2)'); // Violeta
            gradient.addColorStop(0.20, 'rgba(0, 0, 255, 0.2)');    // Azul
            gradient.addColorStop(0.30, 'rgba(0, 191, 255, 0.2)');  // Azul claro
            gradient.addColorStop(0.40, 'rgba(0, 255, 255, 0.2)');  // Ciano
            gradient.addColorStop(0.50, 'rgba(0, 255, 127, 0.2)');  // Verde √°gua
            gradient.addColorStop(0.60, 'rgba(50, 205, 50, 0.2)');  // Verde lima
            gradient.addColorStop(0.70, 'rgba(255, 255, 0, 0.2)');  // Amarelo
            gradient.addColorStop(0.80, 'rgba(255, 165, 0, 0.2)');  // Laranja
            gradient.addColorStop(0.90, 'rgba(255, 69, 0, 0.2)');   // Vermelho laranja
            gradient.addColorStop(1.00, 'rgba(255, 0, 0, 0.2)');    // Vermelho
            
            // Fundo
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Barra de espectro
            ctx.fillStyle = gradient;
            ctx.fillRect(0, height - 25, width, 25);
        }
        
        function drawSmoothLine(spectrum, width, height, maxIntensity) {
            // Criar gradiente para a linha
            const lineGradient = ctx.createLinearGradient(0, 0, width, 0);
            lineGradient.addColorStop(0.0, '#9400d3');  // Violeta
            lineGradient.addColorStop(0.2, '#0000ff');  // Azul
            lineGradient.addColorStop(0.4, '#00ffff');  // Ciano
            lineGradient.addColorStop(0.6, '#00ff00');  // Verde
            lineGradient.addColorStop(0.8, '#ffff00');  // Amarelo
            lineGradient.addColorStop(1.0, '#ff0000');  // Vermelho
            
            // Desenhar linha com SMOOTHING
            ctx.beginPath();
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = lineGradient;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            
            // Usar menos pontos para linha mais suave
            const step = Math.max(1, Math.floor(spectrum.length / 200));
            
            for (let i = 0; i < spectrum.length; i += step) {
                const point = spectrum[i];
                const x = (point.wavelength - 300) / 500 * width;
                const y = height - 30 - (point.intensity / maxIntensity * (height - 60));
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    // Interpola√ß√£o suave entre pontos
                    const prevPoint = spectrum[i - step];
                    const prevX = (prevPoint.wavelength - 300) / 500 * width;
                    const prevY = height - 30 - (prevPoint.intensity / maxIntensity * (height - 60));
                    
                    // Curva de B√©zier para suaviza√ß√£o
                    const cp1x = prevX + (x - prevX) * 0.5;
                    const cp1y = prevY;
                    const cp2x = prevX + (x - prevX) * 0.5;
                    const cp2y = y;
                    
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                }
            }
            
            ctx.stroke();
            
            // Preenchimento suave abaixo da linha
            ctx.lineTo(width, height - 30);
            ctx.lineTo(0, height - 30);
            ctx.closePath();
            
            const fillGradient = ctx.createLinearGradient(0, 0, 0, height);
            fillGradient.addColorStop(0, 'rgba(148, 0, 211, 0.15)');
            fillGradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.1)');
            fillGradient.addColorStop(1, 'rgba(148, 0, 211, 0.05)');
            ctx.fillStyle = fillGradient;
            ctx.fill();
        }
        
        function drawAxesAndInfo(width, height, maxIntensity) {
            // Eixo X
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height - 30);
            ctx.lineTo(width, height - 30);
            ctx.stroke();
            
            // Marcadores importantes para cultivo
            const markers = [
                { wl: 380, label: 'UV-A', color: '#9400d3' },
                { wl: 450, label: 'Azul', color: '#0000ff' },
                { wl: 530, label: 'Verde', color: '#00ff00' },
                { wl: 630, label: 'Vermelho', color: '#ff0000' },
                { wl: 660, label: 'Clorofila', color: '#ff4500' },
                { wl: 730, label: 'Far-Red', color: '#8b0000' }
            ];
            
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            
            markers.forEach(marker => {
                const x = (marker.wl - 300) / 500 * width;
                
                // Linha vertical
                ctx.strokeStyle = marker.color + '40';
                ctx.beginPath();
                ctx.moveTo(x, 20);
                ctx.lineTo(x, height - 30);
                ctx.stroke();
                
                // Marcador
                ctx.fillStyle = marker.color;
                ctx.beginPath();
                ctx.moveTo(x, height - 30);
                ctx.lineTo(x - 5, height - 25);
                ctx.lineTo(x + 5, height - 25);
                ctx.closePath();
                ctx.fill();
                
                // R√≥tulo
                ctx.fillStyle = 'white';
                ctx.fillText(marker.label + ' ' + marker.wl + 'nm', x, height - 10);
            });
            
            // T√≠tulo
            ctx.textAlign = 'left';
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#64b5f6';
            ctx.fillText('Espectro de Alta Resolu√ß√£o', 10, 25);
            
            // Informa√ß√£o de resolu√ß√£o
            ctx.font = '12px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillText('Resolu√ß√£o: 1nm | Suaviza√ß√£o: ' + smoothValue.textContent, 10, 45);
        }
        
        // Fun√ß√£o Gaussiana para distribui√ß√£o
        function gaussian(x, mean, sigma) {
            return Math.exp(-Math.pow(x - mean, 2) / (2 * Math.pow(sigma, 2)));
        }
        
        // 8. PARAR C√ÇMERA
        stopBtn.addEventListener('click', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            video.style.display = 'none';
            placeholder.style.display = 'flex';
            startBtn.style.display = 'block';
            stopBtn.style.display = 'none';
            isCameraActive = false;
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });
        
        // 9. INICIALIZA√á√ÉO
        window.addEventListener('DOMContentLoaded', () => {
            canvas.width = canvas.clientWidth;
            canvas.height = 350;
        });
    </script>
</body>
</html>
